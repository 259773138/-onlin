<!DOCTYPE html>
<html lang="zh-CN" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NexChat | æ··åˆåŠ å¯†ç»ˆç«¯</title>
    <!-- æ ¸å¿ƒåº“ CDN -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="//code.bdstatic.com/npm/leancloud-storage@4.12.0/dist/av-min.js"></script>
    
    <!-- é…ç½® Tailwind -->
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#3b82f6',
                        dark: '#0f172a',
                        darker: '#020617',
                        card: '#1e293b'
                    }
                }
            }
        }
    </script>
    <style>
        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡ */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 3px; }
        .fade-enter-active, .fade-leave-active { transition: opacity 0.2s; }
        .fade-enter-from, .fade-leave-to { opacity: 0; }
        .msg-bubble { max-width: 80%; word-break: break-word; }
    </style>
</head>
<body class="bg-darker text-gray-200 h-screen overflow-hidden flex text-sm">

<div id="app" class="w-full h-full flex flex-col md:flex-row relative">

    <!-- é…ç½®å¼¹çª— (é¦–æ¬¡è¿è¡Œ) -->
    <div v-if="!config.ready" class="fixed inset-0 z-50 bg-black/90 flex items-center justify-center p-4">
        <div class="bg-card p-6 rounded-xl w-full max-w-md border border-gray-700">
            <h2 class="text-xl font-bold text-primary mb-4">ç³»ç»Ÿåˆå§‹åŒ–</h2>
            <p class="text-xs text-gray-400 mb-4">ä¸ºäº†å¯ç”¨å…¬å…±å¤§å…ï¼Œéœ€è¦ LeanCloud (å›½é™…ç‰ˆ) æ”¯æŒã€‚ç§èŠå°†ä½¿ç”¨ P2P ç«¯å¯¹ç«¯åŠ å¯†ã€‚</p>
            <input v-model="config.appId" placeholder="LeanCloud App ID" class="w-full bg-dark p-3 rounded mb-3 border border-gray-700 outline-none focus:border-primary">
            <input v-model="config.appKey" placeholder="LeanCloud App Key" class="w-full bg-dark p-3 rounded mb-4 border border-gray-700 outline-none focus:border-primary">
            <button @click="saveConfig" class="w-full bg-primary hover:bg-blue-600 text-white py-3 rounded font-bold transition">å¯åŠ¨ç³»ç»Ÿ</button>
        </div>
    </div>

    <!-- å·¦ä¾§æ ï¼šè”ç³»äººä¸å¯¼èˆª -->
    <div v-if="config.ready" :class="['md:w-80 w-full flex-col border-r border-gray-800 bg-dark transition-all z-20', activeTab === 'chat' && isMobile ? 'hidden' : 'flex']">
        <!-- å¤´éƒ¨ç”¨æˆ·ä¿¡æ¯ -->
        <div class="p-4 border-b border-gray-800 flex justify-between items-center bg-card">
            <div>
                <div class="font-bold text-white text-lg">{{ myName }}</div>
                <div class="text-xs text-gray-400 cursor-pointer hover:text-primary truncate w-40" @click="copyId" title="ç‚¹å‡»å¤åˆ¶ID">
                    ID: {{ myPeerId }}
                </div>
            </div>
            <div class="flex gap-2">
                <button @click="showAddFriend = true" class="p-2 bg-gray-700 rounded-full hover:bg-gray-600">â•</button>
            </div>
        </div>

        <!-- å¯¼èˆªæ ‡ç­¾ -->
        <div class="flex border-b border-gray-800">
            <button @click="switchChannel('public')" :class="['flex-1 py-3 font-medium transition', currentChannel === 'public' ? 'text-primary border-b-2 border-primary bg-gray-800/50' : 'text-gray-500']">å…¬å…±å¤§å…</button>
            <button @click="switchChannel('private')" :class="['flex-1 py-3 font-medium transition', currentChannel === 'private' ? 'text-primary border-b-2 border-primary bg-gray-800/50' : 'text-gray-500']">ç§èŠåˆ—è¡¨</button>
        </div>

        <!-- åˆ—è¡¨åŒºåŸŸ -->
        <div class="flex-1 overflow-y-auto">
            <!-- å…¬å…±å¤§å…ç®€ä»‹ -->
            <div v-if="currentChannel === 'public'" class="p-4 flex items-center gap-3 cursor-pointer hover:bg-gray-800 transition bg-gray-800/30" @click="enterChat('public')">
                <div class="w-12 h-12 rounded-full bg-blue-900 flex items-center justify-center text-xl">ğŸ“¢</div>
                <div>
                    <div class="font-bold">å…¬å…±é¢‘é“</div>
                    <div class="text-xs text-gray-400">æ‰€æœ‰äººå¯è§ Â· æœåŠ¡å™¨å­˜å‚¨</div>
                </div>
            </div>

            <!-- å¥½å‹åˆ—è¡¨ -->
            <div v-if="currentChannel === 'private'">
                <div v-if="friends.length === 0" class="p-8 text-center text-gray-500 text-xs">
                    æš‚æ— å¥½å‹ï¼Œå»å…¬å…±å¤§å…ç‚¹å‡»ç”¨æˆ·å¤´åƒæ·»åŠ ï¼Œæˆ–ç‚¹å‡»ä¸Šæ–¹â•å·ã€‚
                </div>
                <div v-for="friend in friends" :key="friend.id" @click="enterPrivateChat(friend)" :class="['p-3 flex items-center gap-3 cursor-pointer hover:bg-gray-800 transition border-b border-gray-800/50', activePrivateId === friend.id ? 'bg-gray-800' : '']">
                    <div class="w-10 h-10 rounded-full bg-gradient-to-tr from-green-700 to-green-500 flex items-center justify-center font-bold text-white shadow relative">
                        {{ friend.name.slice(0,1) }}
                        <!-- åœ¨çº¿çŠ¶æ€ç‚¹ -->
                        <div v-if="connections[friend.id]" class="absolute bottom-0 right-0 w-3 h-3 bg-green-400 rounded-full border-2 border-dark"></div>
                    </div>
                    <div class="flex-1 min-w-0">
                        <div class="flex justify-between items-baseline">
                            <div class="font-bold truncate text-gray-200">{{ friend.name }}</div>
                            <div class="text-[10px] text-gray-500">{{ getLastTime(friend.id) }}</div>
                        </div>
                        <div class="text-xs text-gray-500 truncate">
                            {{ connections[friend.id] ? 'ğŸ”— å·²åŠ å¯†è¿æ¥' : 'ğŸ’¤ ç¦»çº¿ (ç‚¹å‡»é‡è¿)' }}
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- å³ä¾§æ ï¼šèŠå¤©çª—å£ -->
    <div v-if="config.ready" :class="['flex-1 flex flex-col bg-darker transition-all', activeTab === 'list' && isMobile ? 'hidden' : 'flex']">
        
        <!-- èŠå¤©å¤´éƒ¨ -->
        <div class="h-16 border-b border-gray-800 flex items-center px-4 bg-card/80 backdrop-blur justify-between">
            <div class="flex items-center gap-3">
                <button v-if="isMobile" @click="activeTab = 'list'" class="mr-2 text-gray-400">â¬…</button>
                <div v-if="chatType === 'public'" class="w-8 h-8 rounded-full bg-blue-900 flex items-center justify-center">ğŸ“¢</div>
                <div v-else class="w-8 h-8 rounded-full bg-green-700 flex items-center justify-center">{{ currentChatName.slice(0,1) }}</div>
                <div>
                    <div class="font-bold">{{ currentChatName }}</div>
                    <div class="text-xs text-gray-500 flex items-center gap-1">
                        <span v-if="chatType === 'private' && !isCurrentPeerConnected" class="text-red-500">âš  æœªè¿æ¥</span>
                        <span v-if="chatType === 'private' && isCurrentPeerConnected" class="text-green-500">ğŸ”’ P2P ç«¯å¯¹ç«¯åŠ å¯†</span>
                        <span v-if="chatType === 'public'">â˜ï¸ äº‘ç«¯åŒæ­¥</span>
                    </div>
                </div>
            </div>
            <!-- ç§èŠæ—¶çš„æ“ä½œæ  -->
            <div v-if="chatType === 'private'" class="flex gap-2">
                 <button @click="connectToFriend(activePrivateId)" class="text-xs bg-gray-700 px-3 py-1 rounded hover:bg-gray-600" v-if="!isCurrentPeerConnected">é‡è¿</button>
                 <button @click="deleteFriend(activePrivateId)" class="text-xs text-red-400 px-2 hover:bg-red-900/30 rounded">åˆ é™¤</button>
            </div>
        </div>

        <!-- æ¶ˆæ¯åˆ—è¡¨ -->
        <div id="msg-container" class="flex-1 overflow-y-auto p-4 space-y-4">
            <!-- æ¬¢è¿è¯­ -->
            <div class="text-center text-xs text-gray-600 my-4">
                {{ chatType === 'public' ? 'æ­¤é¢‘é“æ¶ˆæ¯å­˜å‚¨åœ¨ LeanCloud' : 'æ­¤é¢‘é“æ¶ˆæ¯ä»…å­˜å‚¨åœ¨åŒæ–¹è®¾å¤‡æœ¬åœ°' }}
            </div>

            <div v-for="(msg, index) in currentMessages" :key="index" :class="['flex flex-col', msg.isMe ? 'items-end' : 'items-start']">
                <!-- æ¶ˆæ¯å¤´ (ç‚¹å‡»æ·»åŠ å¥½å‹) -->
                <div v-if="!msg.isMe && chatType === 'public'" @click="promptAddFriend(msg)" class="text-[10px] text-gray-500 mb-1 ml-1 cursor-pointer hover:text-primary hover:underline">
                    {{ msg.senderName }} (ç‚¹å‡»æ·»åŠ )
                </div>
                <div v-else class="text-[10px] text-gray-500 mb-1 mx-1">{{ msg.time }}</div>

                <div :class="['msg-bubble px-4 py-2 rounded-2xl text-sm shadow-md', msg.isMe ? 'bg-primary text-white rounded-br-sm' : 'bg-gray-700 text-gray-100 rounded-bl-sm']">
                    {{ msg.text }}
                </div>
            </div>
        </div>

        <!-- è¾“å…¥æ¡† -->
        <div class="p-3 bg-card border-t border-gray-800">
            <div class="flex gap-2 bg-dark p-1 rounded-2xl border border-gray-700">
                <input v-model="inputText" @keyup.enter="sendMessage" placeholder="å‘é€æ¶ˆæ¯..." class="flex-1 bg-transparent px-4 py-2 outline-none text-white">
                <button @click="sendMessage" class="bg-primary hover:bg-blue-600 text-white rounded-xl px-6 font-bold transition">â¤</button>
            </div>
        </div>
    </div>

    <!-- æ·»åŠ å¥½å‹å¼¹çª— -->
    <div v-if="showAddFriend" class="fixed inset-0 z-50 bg-black/80 flex items-center justify-center p-4">
        <div class="bg-card p-5 rounded-xl w-full max-w-sm border border-gray-700">
            <h3 class="font-bold mb-3">æ·»åŠ å¥½å‹</h3>
            <input v-model="newFriendId" placeholder="è¾“å…¥å¯¹æ–¹ ID" class="w-full bg-dark p-2 rounded mb-2 border border-gray-700 outline-none">
            <input v-model="newFriendName" placeholder="ç»™TAå¤‡æ³¨æ˜µç§°" class="w-full bg-dark p-2 rounded mb-4 border border-gray-700 outline-none">
            <div class="flex gap-2">
                <button @click="showAddFriend = false" class="flex-1 bg-gray-700 py-2 rounded">å–æ¶ˆ</button>
                <button @click="addFriendAction" class="flex-1 bg-primary py-2 rounded">æ·»åŠ </button>
            </div>
        </div>
    </div>

</div>

<script>
    const { createApp, ref, reactive, computed, onMounted, nextTick, watch } = Vue;

    createApp({
        setup() {
            // çŠ¶æ€ç®¡ç†
            const config = reactive({ ready: false, appId: '', appKey: '' });
            const myPeerId = ref('gen...');
            const myName = ref(localStorage.getItem('nex_name') || 'åŒ¿å' + Math.floor(Math.random()*9999));
            
            // UI çŠ¶æ€
            const isMobile = ref(window.innerWidth < 768);
            const activeTab = ref('list'); // 'list' or 'chat' (mobile)
            const currentChannel = ref('public'); // 'public' or 'private'
            const chatType = ref('public'); // å½“å‰æ­£åœ¨èŠå¤©çš„ç±»å‹
            const activePrivateId = ref(null); // å½“å‰ç§èŠå¯¹è±¡çš„ID
            const showAddFriend = ref(false);
            
            // æ•°æ®
            const friends = ref(JSON.parse(localStorage.getItem('nex_friends') || '[]'));
            const publicMsgs = ref([]);
            const privateHistory = reactive(JSON.parse(localStorage.getItem('nex_private_history') || '{}'));
            const connections = reactive({}); // æ´»è·ƒçš„ P2P è¿æ¥
            
            // è¾“å…¥
            const inputText = ref('');
            const newFriendId = ref('');
            const newFriendName = ref('');

            // æ ¸å¿ƒå¯¹è±¡
            let peer = null;

            // --- åˆå§‹åŒ–é€»è¾‘ ---
            onMounted(() => {
                // è¯»å–é…ç½®
                const cachedId = localStorage.getItem('lc_id');
                const cachedKey = localStorage.getItem('lc_key');
                if(cachedId && cachedKey) {
                    config.appId = cachedId; config.appKey = cachedKey;
                    initSystem();
                }

                // å“åº”å¼å¸ƒå±€
                window.addEventListener('resize', () => {
                    isMobile.value = window.innerWidth < 768;
                });
            });

            const saveConfig = () => {
                if(!config.appId || !config.appKey) return alert("è¯·å¡«å†™å®Œæ•´");
                localStorage.setItem('lc_id', config.appId);
                localStorage.setItem('lc_key', config.appKey);
                initSystem();
            }

            const initSystem = () => {
                config.ready = true;
                initLeanCloud();
                initPeer();
            }

            // --- LeanCloud (å…¬å…±) ---
            const initLeanCloud = () => {
                AV.init({ appId: config.appId, appKey: config.appKey, serverURLs: "https://avoscloud.com" });
                
                // è½®è¯¢è·å–æ¶ˆæ¯
                setInterval(fetchPublicMsgs, 3000);
                fetchPublicMsgs();
            }

            const fetchPublicMsgs = async () => {
                const query = new AV.Query('PublicChat');
                query.descending('createdAt');
                query.limit(50);
                try {
                    const res = await query.find();
                    const newMsgs = res.map(m => ({
                        text: m.get('text'),
                        senderName: m.get('senderName'),
                        senderId: m.get('senderId'), // å…³é”®ï¼šç”¨äºæ·»åŠ å¥½å‹
                        time: m.createdAt.toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'}),
                        isMe: m.get('senderId') === myPeerId.value
                    })).reverse();
                    
                    // ç®€å•å»é‡æ›´æ–°
                    if(newMsgs.length && (publicMsgs.value.length === 0 || newMsgs[newMsgs.length-1].time !== publicMsgs.value[publicMsgs.value.length-1].time)) {
                        publicMsgs.value = newMsgs;
                        if(chatType.value === 'public') scrollToBottom();
                    }
                } catch(e) { console.error(e); }
            }

            // --- PeerJS (ç§èŠ) ---
            const initPeer = () => {
                // ç”Ÿæˆå›ºå®šIDæˆ–éšæœºID
                let savedId = localStorage.getItem('nex_peer_id');
                if(!savedId) {
                    savedId = 'user_' + Math.random().toString(36).substr(2, 9);
                    localStorage.setItem('nex_peer_id', savedId);
                }
                
                peer = new Peer(savedId, { debug: 1 });

                peer.on('open', (id) => {
                    myPeerId.value = id;
                });

                peer.on('connection', (conn) => {
                    handleConnection(conn);
                    // å¦‚æœå¯¹æ–¹ä¸åœ¨å¥½å‹åˆ—è¡¨ï¼Œæç¤ºæ·»åŠ ? (è¿™é‡Œç®€åŒ–ä¸ºè‡ªåŠ¨æ¥æ”¶ä½†ä¸ä¿å­˜ä¸ºå¥½å‹)
                    // å®é™…é€»è¾‘ï¼šå¦‚æœä¸åœ¨å¥½å‹åˆ—è¡¨ï¼Œæš‚æ—¶ä½œä¸ºé™Œç”Ÿäººå¯¹è¯
                });

                peer.on('error', (err) => {
                    console.error(err);
                    if(err.type === 'peer-unavailable') {
                        pushPrivateMsg(activePrivateId.value, "ç³»ç»Ÿ", "å¯¹æ–¹ä¸åœ¨çº¿æˆ–è¿æ¥å¤±è´¥", false);
                    }
                });
            }

            const handleConnection = (conn) => {
                // ç›‘å¬æ•°æ®
                conn.on('data', (data) => {
                    // æ”¶åˆ°ç§èŠæ¶ˆæ¯
                    pushPrivateMsg(conn.peer, null, data.text, false);
                });
                
                conn.on('open', () => {
                    connections[conn.peer] = conn; // å­˜å…¥æ´»è·ƒè¿æ¥æ± 
                });

                conn.on('close', () => {
                    delete connections[conn.peer];
                });
                
                // å°è¯•åå‘ä¿å­˜è¿æ¥ä»¥ä¾¿å¤ç”¨
                connections[conn.peer] = conn;
            }

            const connectToFriend = (id) => {
                if(!peer || connections[id]) return;
                const conn = peer.connect(id);
                handleConnection(conn);
            }

            // --- ä¸šåŠ¡é€»è¾‘ ---
            
            // åˆ‡æ¢é¢‘é“ Tab
            const switchChannel = (channel) => {
                currentChannel.value = channel;
            }

            // è¿›å…¥å…¬å…±èŠå¤©
            const enterChat = (type) => {
                chatType.value = type;
                activeTab.value = 'chat';
                activePrivateId.value = null;
                scrollToBottom();
            }

            // è¿›å…¥ç§èŠ
            const enterPrivateChat = (friend) => {
                chatType.value = 'private';
                activeTab.value = 'chat';
                activePrivateId.value = friend.id;
                
                // å°è¯•è¿æ¥
                if(!connections[friend.id]) {
                    connectToFriend(friend.id);
                }
                
                scrollToBottom();
            }

            const sendMessage = async () => {
                const text = inputText.value.trim();
                if(!text) return;

                if(chatType.value === 'public') {
                    // å‘é€ LeanCloud
                    const Chat = AV.Object.extend('PublicChat');
                    const chat = new Chat();
                    chat.set('text', text);
                    chat.set('senderName', myName.value);
                    chat.set('senderId', myPeerId.value);
                    await chat.save();
                    fetchPublicMsgs(); // ç«‹å³åˆ·æ–°
                } else {
                    // å‘é€ PeerJS
                    const targetId = activePrivateId.value;
                    const conn = connections[targetId];
                    if(conn && conn.open) {
                        conn.send({ text });
                        pushPrivateMsg(targetId, null, text, true);
                    } else {
                        pushPrivateMsg(targetId, "ç³»ç»Ÿ", "æœªè¿æ¥ï¼Œæ— æ³•å‘é€ã€‚è¯·ç‚¹å‡»å³ä¸Šè§’é‡è¿ã€‚", false);
                    }
                }
                inputText.value = '';
            }

            // å­˜å‚¨ç§èŠè®°å½•
            const pushPrivateMsg = (peerId, senderName, text, isMe) => {
                if(!privateHistory[peerId]) privateHistory[peerId] = [];
                privateHistory[peerId].push({
                    text, 
                    isMe, 
                    senderName,
                    time: new Date().toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})
                });
                // å­˜å…¥æœ¬åœ°
                localStorage.setItem('nex_private_history', JSON.stringify(privateHistory));
            }

            // å¥½å‹ç³»ç»Ÿ
            const addFriendAction = () => {
                if(!newFriendId.value) return;
                const exists = friends.value.find(f => f.id === newFriendId.value);
                if(!exists) {
                    friends.value.push({
                        id: newFriendId.value,
                        name: newFriendName.value || 'ç”¨æˆ·'
                    });
                    localStorage.setItem('nex_friends', JSON.stringify(friends.value));
                }
                showAddFriend.value = false;
                newFriendId.value = '';
                newFriendName.value = '';
                switchChannel('private');
            };

            const promptAddFriend = (msg) => {
                if(msg.isMe) return;
                newFriendId.value = msg.senderId;
                newFriendName.value = msg.senderName;
                showAddFriend.value = true;
            }

            const deleteFriend = (id) => {
                if(confirm('ç¡®å®šåˆ é™¤å¥½å‹ï¼Ÿè®°å½•å°†ä¿ç•™ã€‚')) {
                    friends.value = friends.value.filter(f => f.id !== id);
                    localStorage.setItem('nex_friends', JSON.stringify(friends.value));
                    enterChat('public');
                }
            }

            // å·¥å…·
            const scrollToBottom = () => {
                nextTick(() => {
                    const container = document.getElementById('msg-container');
                    if(container) container.scrollTop = container.scrollHeight;
                });
            }
            
            const copyId = () => {
                navigator.clipboard.writeText(myPeerId.value);
                alert("IDå·²å¤åˆ¶");
            }

            // è®¡ç®—å±æ€§
            const currentChatName = computed(() => {
                if(chatType.value === 'public') return 'å…¬å…±é¢‘é“';
                const f = friends.value.find(f => f.id === activePrivateId.value);
                return f ? f.name : activePrivateId.value;
            });

            const currentMessages = computed(() => {
                if(chatType.value === 'public') return publicMsgs.value;
                return privateHistory[activePrivateId.value] || [];
            });

            const isCurrentPeerConnected = computed(() => {
                if(chatType.value !== 'private') return false;
                const conn = connections[activePrivateId.value];
                return conn && conn.open;
            });

            const getLastTime = (id) => {
                const msgs = privateHistory[id];
                if(msgs && msgs.length) return msgs[msgs.length-1].time;
                return '';
            }

            return {
                config, saveConfig, myPeerId, myName, isMobile, activeTab, 
                currentChannel, chatType, activePrivateId, friends, 
                inputText, showAddFriend, newFriendId, newFriendName,
                currentChatName, currentMessages, isCurrentPeerConnected, connections,
                switchChannel, enterChat, enterPrivateChat, sendMessage,
                addFriendAction, promptAddFriend, deleteFriend, copyId, 
                connectToFriend, getLastTime
            };
        }
    }).mount('#app');
</script>
</body>
</html>